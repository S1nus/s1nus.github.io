<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cnode&#39;s blog on cnode.phd</title>
    <link>https://cnode.phd/</link>
    <description>Recent content in cnode&#39;s blog on cnode.phd</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>Copyright © 2025, colludingnode</copyright>
    <lastBuildDate>Mon, 01 Dec 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://cnode.phd/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Learning how to read zkSNARK papers</title>
      <link>https://cnode.phd/demystifying_formal_zksnark_jargon/</link>
      <pubDate>Mon, 01 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://cnode.phd/demystifying_formal_zksnark_jargon/</guid>
      <description>&lt;p&gt;There are a lot of digestible explainers out there for popular ZK proof systems and their components, but reading the actual papers is hard; because the authors write rigorous proofs that the system has various security properties. While trying to understand proof systems that aren&amp;rsquo;t as &amp;ldquo;popular&amp;rdquo; as the classics like PLONK and STARKs, I became unsatisfied with not easily knowing &lt;em&gt;why&lt;/em&gt; the protocol works, and found it helpful to look into these security proofs to make sense of them.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Create for an audience.</title>
      <link>https://cnode.phd/build_for_an_audience/</link>
      <pubDate>Sun, 26 Oct 2025 00:00:00 +0000</pubDate>
      <guid>https://cnode.phd/build_for_an_audience/</guid>
      <description>&lt;p&gt;Conventional advice says to make art for yourself. Write for yourself, make music for yourself, and build products that you’d like to use, for yourself.&lt;/p&gt;&#xA;&lt;p&gt;I disagree.&lt;/p&gt;&#xA;&lt;p&gt;I don’t mean that you should chase external validation; because chasing clout to fit in with the cool kids will make you empty inside. However, creating for your lonely self won’t satisfy you either. Loneliness is a symptom of something wrong at a deeper level.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Offline is like a Roller Coaster</title>
      <link>https://cnode.phd/phone_rollercoaster/</link>
      <pubDate>Fri, 19 Sep 2025 00:00:00 +0000</pubDate>
      <guid>https://cnode.phd/phone_rollercoaster/</guid>
      <description>&lt;p&gt;Thoughts race through my head like the chatter of a crowded subway train, or a popular east village bar on a Friday night; only instead of strangers’ conversations, it’s my own vague anxieties and regrets. Scrolling on apps quiets all the voices. Each post that I read while scrolling is a singular, focused, individual thought.&lt;/p&gt;&#xA;&lt;p&gt;These days I don’t have the patience to read books. I can barely watch movies or TV. Watching YouTube videos feels productive in comparison to scrolling memes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Slop and Polish</title>
      <link>https://cnode.phd/resist_ai_slop/</link>
      <pubDate>Thu, 07 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://cnode.phd/resist_ai_slop/</guid>
      <description>&lt;p&gt;Mark Twain once said “I didn&amp;rsquo;t have time to write a short letter, so I wrote a long one instead.”&lt;/p&gt;&#xA;&lt;p&gt;Remove clicks from your UIs. Remove steps from the dev experience. Remove words from your tweets, from your blog posts, from your technical docs, from your research papers. As Mark Twain implied, this requires effort; the result of the effort is called &lt;em&gt;&lt;a href=&#34;https://www.merriam-webster.com/dictionary/polish&#34;&gt;polish&lt;/a&gt;&lt;/em&gt;, and the lack of &lt;em&gt;polish&lt;/em&gt; is called &lt;em&gt;&lt;a href=&#34;https://www.merriam-webster.com/dictionary/slop&#34;&gt;slop&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>AIR Development Pt. 2</title>
      <link>https://cnode.phd/intro_to_air_development_pt_2/</link>
      <pubDate>Fri, 01 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://cnode.phd/intro_to_air_development_pt_2/</guid>
      <description>&lt;p&gt;see &lt;a href=&#34;../intro_air_development&#34;&gt;part 1&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;this-work-is-already-done&#34;&gt;This work is already done.&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://succinct.xyz&#34;&gt;Succinct&lt;/a&gt; has already implemented sha256 in Plonky3 (as an &lt;a href=&#34;https://github.com/succinctlabs/sp1/tree/dev/crates/core/machine/src/syscall/precompiles/sha256&#34;&gt;SP1 precompile&lt;/a&gt;), so why do this as a learning excersize? Isn&amp;rsquo;t there something more useful to do as a learning excersize?&lt;/p&gt;&#xA;&lt;p&gt;Succinct Labs&amp;rsquo; sha256 precompile is heavily coupled to SP1 itself. The architecture of SP1 has deeply-baked optimizations built into its proof system. Sha256 is a great example of a computation that leverages cross-table lookups, and lookups from precomputed tables. It is ubiquitous in applications that benefit from ZK tech. Learning how to implement it optimally in a circuit will be useful when we later want to arithmetize it for new proof systems like &lt;a href=&#34;https://github.com/nethermindEth/latticefold/&#34;&gt;Nethermind&amp;rsquo;s LatticeFold&lt;/a&gt;, or &lt;a href=&#34;https://github.com/privacy-scaling-explorations/sonobe/&#34;&gt;PSE&amp;rsquo;s Sonobe&lt;/a&gt;- research implementations that seem to favor &lt;a href=&#34;https://eprint.iacr.org/2023/552&#34;&gt;CCS&lt;/a&gt;, a constraint system that doesn&amp;rsquo;t have any good tooling yet, although it can capture R1CS, Plonkish, or AIR without any overhead; and I wonder if that implies that it can express some computations more efficiently.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cyclotomic Fields and LatticeFold</title>
      <link>https://cnode.phd/cyclotomic_fields/</link>
      <pubDate>Thu, 31 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://cnode.phd/cyclotomic_fields/</guid>
      <description>&lt;h1 id=&#34;cyclotomic-fields-and-latticefold&#34;&gt;Cyclotomic Fields and LatticeFold&lt;/h1&gt;&#xA;&lt;p&gt;You can go far as a ZK dev without any formal training in abstract or linear algebra. I managed to understand STARKs, pairings, plonk, KZG, and even folding schemes from a software engineering angle, without needing to dive too deep into algebra topics. However, to understand &lt;a href=&#34;https://eprint.iacr.org/2024/257&#34;&gt;LatticeFold&lt;/a&gt;, this has not been the case.&lt;/p&gt;&#xA;&lt;h2 id=&#34;why-study-latticefold&#34;&gt;Why study LatticeFold?&lt;/h2&gt;&#xA;&lt;p&gt;I am obsessed with &lt;em&gt;succinct blockchains&lt;/em&gt;, ever since stumbling upon &lt;a href=&#34;https://minaprotocol.com/wp-content/uploads/technicalWhitepaper.pdf&#34;&gt;Mina&lt;/a&gt; several years ago, and my motivation for learning ZK is mainly centered around improving this construction as much as possible. I dream of a high TPS succinct blockchain, with instant-syncing light nodes and &lt;a href=&#34;https://arxiv.org/abs/1809.09044&#34;&gt;data availability verification&lt;/a&gt;. This is the white whale I have chased for years now.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Intro to AIR development</title>
      <link>https://cnode.phd/intro_air_development/</link>
      <pubDate>Sun, 20 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://cnode.phd/intro_air_development/</guid>
      <description>&lt;h1 id=&#34;intro-to-air-development&#34;&gt;Intro to AIR development&lt;/h1&gt;&#xA;&lt;p&gt;Celestia&amp;rsquo;s zk blob inclusion proofs are powered by SP1, and it spends hundreds of thousands of riscV cycles on serialization. This overhead made me wonder if a custom AIR for blob inclusion proofs could have impressive savings- either as a standalone STARK, or as an SP1 precompile.&lt;/p&gt;&#xA;&lt;p&gt;To develop such an AIR, first you obtain an AIR for sha256, adapt it to compute merkle proofs, and finally perform NMT-specific checks.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Tree-Folding &amp; Protogalaxy</title>
      <link>https://cnode.phd/folding_with_protogalaxy/</link>
      <pubDate>Tue, 29 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://cnode.phd/folding_with_protogalaxy/</guid>
      <description>&lt;h2 id=&#34;tree-folding-part-1&#34;&gt;Tree-Folding part 1&lt;/h2&gt;&#xA;&lt;p&gt;This series is about approaching ZK research from a software-engineering perspective. We will be studying folding schemes by implementing &amp;ldquo;tree-folding&amp;rdquo; for &lt;a href=&#34;https://eprint.iacr.org/2023/1106.pdf&#34;&gt;protogalaxy&lt;/a&gt; using &lt;a href=&#34;https://github.com/privacy-scaling-explorations/sonobe/&#34;&gt;Sonobe&lt;/a&gt;, to answer some research questions.&lt;/p&gt;&#xA;&lt;h2 id=&#34;recursive-zk-proofs&#34;&gt;Recursive ZK Proofs&lt;/h2&gt;&#xA;&lt;p&gt;When you verify a zk proof inside of another zk proof, that’s called a recursive zk proof. Although it sounds silly; perhaps like something Xzibit would say on Pimp My Ride, recursive proof composition is extremely useful!&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
